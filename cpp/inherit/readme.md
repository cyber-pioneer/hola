基类构造函数的调用：

当创建派生类对象时，首先会调用基类的构造函数，以确保基类部分被正确初始化。
如果基类构造函数需要参数，派生类的构造函数必须通过成员初始化列表显式地调用基类的构造函数。
继承的层次结构：

派生类继承了基类的所有成员变量（无论访问权限如何，但private成员在派生类中是不可直接访问的）和除构造函数与析构函数之外的所有成员函数。
如果基类有多个层次（即多层继承），则每个层次的基类构造函数都会按照从顶层到底层的顺序被调用。
派生类的构造函数：

派生类的构造函数负责初始化派生类新增的成员变量。
派生类的构造函数可以在初始化列表中调用基类的构造函数，以及初始化派生类自己的成员。
内存布局：

**在内存中，派生类对象包含基类部分（基类的成员变量）和派生类新增的部分（派生类的成员变量）**。
基类部分在内存中的排列先于派生类部分，这反映了继承的“是”（is-a）关系，即派生类对象是基类对象的一种特殊类型。
切片问题（Slicing）:

当使用基类指针或引用来指向派生类对象，并通过该指针或引用进行值的传递或赋值时，只有基类部分会被复制或传递，派生类特有的部分会被“切掉”。这是需要特别注意的，因为它可能导致数据丢失或意外行为。
多态性：

继承与多态紧密相关。通过基类指针或引用调用虚函数时，会实现动态绑定（dynamic binding），即根据对象的实际类型（而不是指针或引用的类型）来确定要调用的函数。
这允许在运行时根据对象的实际类型来执行不同的操作，是面向对象编程的重要特性之一。
析构函数的调用：

当派生类对象超出其作用域或被显式删除时，析构函数会被调用以释放资源。
**析构函数的调用顺序与构造函数的调用顺序相反：首先调用派生类的析构函数，然后调用基类的析构函数。**
