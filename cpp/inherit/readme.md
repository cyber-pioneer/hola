## 基类构造函数的调用：

当创建派生类对象时，首先会调用基类的构造函数，以确保基类部分被正确初始化。
如果基类构造函数需要参数，派生类的构造函数必须通过成员初始化列表显式地调用基类的构造函数。
继承的层次结构：

派生类继承了基类的所有成员变量（无论访问权限如何，但private成员在派生类中是不可直接访问的）和除构造函数与析构函数之外的所有成员函数。
如果基类有多个层次（即多层继承），则每个层次的基类构造函数都会按照从顶层到底层的顺序被调用。
派生类的构造函数：

派生类的构造函数负责初始化派生类新增的成员变量。
派生类的构造函数可以在初始化列表中调用基类的构造函数，以及初始化派生类自己的成员。
内存布局：

**在内存中，派生类对象包含基类部分（基类的成员变量）和派生类新增的部分（派生类的成员变量）**。
基类部分在内存中的排列先于派生类部分，这反映了继承的“是”（is-a）关系，即派生类对象是基类对象的一种特殊类型。
切片问题（Slicing）:

当使用基类指针或引用来指向派生类对象，并通过该指针或引用进行值的传递或赋值时，只有基类部分会被复制或传递，派生类特有的部分会被“切掉”。这是需要特别注意的，因为它可能导致数据丢失或意外行为。
多态性：

继承与多态紧密相关。通过基类指针或引用调用虚函数时，会实现动态绑定（dynamic binding），即根据对象的实际类型（而不是指针或引用的类型）来确定要调用的函数。
这允许在运行时根据对象的实际类型来执行不同的操作，是面向对象编程的重要特性之一。
析构函数的调用：

当派生类对象超出其作用域或被显式删除时，析构函数会被调用以释放资源。
**析构函数的调用顺序与构造函数的调用顺序相反：首先调用派生类的析构函数，然后调用基类的析构函数。**


## Q: 为什么派生类不能继承构造函数？
构造函数的主要作用是初始化对象。每个类都有其自己的数据成员和可能需要执行的特定初始化逻辑。基类的构造函数被设计为初始化基类对象，它可能不会（也通常不会）考虑到派生类中新增的数据成员。因此，派生类需要自己的构造函数来确保正确地初始化其所有成员

## Q: 哪些成员不能被继承，为什么？
**构造函数与析构函数：**

构造函数和析构函数不被继承，因为它们是用于对象的创建和销毁的特殊函数。每个类都需要根据自己的需要来定义对象的初始化（构造函数）和清理（析构函数）过程。派生类可以显式调用基类的构造函数和析构函数，但它们不会自动被继承并在派生类对象创建或销毁时调用。
赋值运算符：

**赋值运算符（如operator=）**通常也不被继承，因为每个类可能有不同的数据成员和资源管理需求。派生类需要定义自己的赋值运算符来处理其特有的成员。
友元函数和友元类：

**友元关系**不是继承性的，因为友元函数不属于这个类。如果基类将一个函数或类声明为友元，这种友元关系不会自动延伸到派生类。派生类需要显式地重新声明这些友元关系。
私有成员（private members）：

派生类不能直接访问基类的私有成员。私有成员是基类的实现细节，被封装在基类内部，对派生类是不可见的。虽然私有成员在物理上存在于派生类对象中，但派生类没有权限直接访问它们。
保护成员（protected members）：

虽然保护成员不是“不能继承”，但值得指出的是，派生类可以访问但不能直接继承基类的保护成员。保护成员在派生类中是可访问的，但仍属于基类，并非派生类自己的成员。
静态成员：

**静态成员**（包括静态数据成员和静态成员函数）属于类本身，而不是类的实例。派生类不会继承基类的静态成员，但可以通过作用域解析运算符（::）来访问基类的静态成员。
某些类型的成员函数：

如果基类的成员函数与派生类的需求不符（例如，返回类型、参数列表或访问级别不同），派生类可能需要重载或隐藏这些成员函数，而不是继承它们。
