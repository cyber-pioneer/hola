## 程序运行原理
c++程序运行阶段：**预处理**、**编译**、**汇编**、**链接**以及**执行**
### 预处理阶段
预处理阶段会处理源代码中的预处理指令，比如宏替换、条件编译、包含头文件等。你可以使用-E选项来让GCC只进行预处理并输出结果。

```
g++ -E source.cc -o preprocessed.i

```
这会将source.cc预处理后的结果输出到preprocessed.i文件中。

### 编译阶段
编译阶段将预处理后的代码转换成汇编代码。你可以使用-S选项来让GCC进行编译并输出汇编代码。
会涉及一些检查，比如函数的重复定义。对于声明而未定义的函数，这个阶段会保留一个占位符


```
g++ -S preprocessed.i -o assembly.s
```
或者直接从源代码生成汇编代码：


```
g++ -S source.cc -o assembly.s
```
这会将编译后的汇编代码输出到assembly.s文件中。

### 汇编阶段
汇编阶段将汇编代码转换成目标文件，即机器代码的二进制格式，但还未进行链接。你可以使用-c选项来让GCC进行汇编并输出目标文件。


```
g++ -c assembly.s -o object.o
```
或者直接从源代码生成目标文件：


```
g++ -c source.cc -o object.o
```
这会将汇编后的目标文件输出到object.o文件中。

### 链接阶段
链接阶段将多个目标文件以及所需的库文件链接成一个可执行文件。通常，链接是由编译器自动完成的，但如果你想单独进行链接，可以使用ld链接器。然而，在大多数情况下，你只需使用g++来执行链接。
当链接的时候找不到已声明函数的定义，链接器会报错。
```
/usr/local/bin/ld: object.o: in function `main':
source.cc:(.text+0xa): undefined reference to `fn(int)'
collect2: error: ld returned 1 exit status
```


```
g++ object.o -o program
```
如果你有多个目标文件，可以一并列出：


```
g++ object1.o object2.o -o program
```
这将生成最终的可执行文件program。

### 执行阶段
最后，你可以运行生成的可执行文件来执行你的程序。


```
./program
```
请注意，上述步骤是分开演示的，但在实际开发中，你通常只需运行一次g++命令即可自动完成所有阶段并生成可执行文件，例如：


```
g++ source.cc -o program
```

## 声明和定义
### 函数声明：

告知编译器：函数声明的主要目的是告诉编译器函数的名称、返回类型以及参数列表。这样，编译器在编译包含函数调用的代码时，能够检查函数调用的正确性（例如，参数的类型和数量是否匹配）。

不分配内存：重要的是要理解，函数声明本身并不为函数分配任何内存空间。它只是一个说明，表明函数将在其他地方定义。

可多次声明：在程序中，可以在不同的位置多次声明同一个函数，只要这些声明是一致的（即返回类型、函数名和参数列表相同）。

### 函数定义：

实现功能：函数定义是函数的具体实现，它包含了函数体——一组执行特定任务的语句。这些语句描述了函数在被调用时应该执行的操作。

分配内存：当程序被编译时，编译器会为函数的代码分配内存空间。这个内存空间存储在程序的二进制文件中，并在程序运行时被加载到进程的地址空间中。因此，函数定义确实占用物理存储空间（在磁盘上）和虚拟内存空间（在运行时）。

唯一性：与函数声明不同，每个函数只能有一个定义。这是因为多个定义会导致编译器或链接器混淆，不知道应该使用哪个实现。

链接过程：**在编译时，编译器会将函数调用与函数定义相关联。如果编译器在编译时找不到函数的定义（例如，如果函数定义在另一个文件中），它会在生成的目标文件中留下一个占位符**。然后，链接器的任务是在将程序组合成可执行文件时解析这些占位符，确保每个函数调用都链接到相应的函数定义。
