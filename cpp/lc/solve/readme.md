DFS（深度优先搜索）、动态规划、回溯法、递归都是计算机科学中用于解决各种问题的算法策略和技术。虽然它们各自有其独特的特点和应用场景，但它们之间也存在一定的关联和交叉。

**递归**：递归是一种算法设计策略，其中函数直接或间接地调用自身。递归通常用于将问题分解为更小的子问题，直到子问题可以直接解决为止。递归通常需要一个明确的退出条件，以避免无限递归。

递归模板
```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
 做选择
        backtrack(路径, 选择列表)
 撤销选择（比如把原来在记录表中的标记值换成初始未改动的）

```
这么看来，回溯法的核心其实就是for循环，这么一来是不是好理解多了？而实际刷题时，同一道题目可能会有回溯法和动态规划两种可选项。最经典的例子就是climb stairs，也就是有多少种方法可以爬到最上层的台阶。如果用回溯法的思路：每一层台阶都可以选择跳1层或者跳2层，也就是进行一次“选择”，如果每一次都只跳1层，那到达顶层也就是发现了一种“路径”，这时候就回溯到上一层台阶，在这层台阶尝试其他的跳法，这样又多发现一种“路径”… 当我们不断尝试，回溯到起点时，我们就探索完了所有路径。

**DFS（深度优先搜索）**：DFS 是一种用于遍历或搜索树或图的算法。在DFS中，算法尽可能深地搜索树的分支。当节点v的所在边都已被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS可以通过递归来实现。

**回溯法**：回溯法是一种基于试错的算法，它通过探索所有可能的候选解来找出所有（或某个）解。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来丢弃该解，即“回溯”并尝试另一个可能的解。回溯法经常与递归和DFS结合使用，以系统地探索所有可能的解决方案。

**动态规划**：动态规划是一种用于解决具有重叠子问题和最优子结构性质的问题的方法。它通过将问题分解为简单的子问题（通常是自底向上的方式），并将子问题的解存储在表中，以便在需要时可以快速查找，从而避免重复计算。动态规划通常使用填表的方式来逐步构建问题的解，而不是像回溯法那样显式地搜索所有可能的解。

这些概念之间的关系可以总结如下：

递归和DFS都涉及到将问题分解为更小的子问题，并可能涉及到对子问题的重复访问。递归通常用于实现DFS，但DFS也可以通过迭代的方式实现。

回溯法和DFS都用于系统地探索所有可能的解决方案。回溯法通常使用DFS作为搜索策略，但也可以与其他搜索策略结合使用。

动态规划与回溯法和DFS在解决问题的方式上有所不同。动态规划通过自底向上的方式构建问题的解，并利用子问题的解来避免重复计算。而回溯法和DFS则通过显式地搜索所有可能的解来找出问题的解。


dp 与 recursion(递归)dp 与 dfs/backtrack(回溯)dfs 与 backtrackdfs/backtrack 与 recursion动态规划的实质是记忆。这一点对理解动态规划很重要。这一论断需要问题同时满足两个条件。可以记忆，即最优子结构，或称无后效性。具有此性质的问题均可以使用分治来解决（动态规划与贪心可以看作分治的特例），而分治几乎都是以递归的形式呈现的，故动态规划和贪心也可以用递归的方法解决（当然，用递推也可以；不过递归形式看起来清楚）。需要记忆，即重叠子问题。这就是它与深度优先搜索的主要区别。像八皇后问题，用dp也没问题，只是没有重叠子问题，用了 dp 也不能优化，反而浪费空间，还增加代码量。回溯与 dfs 类似。回溯是 dfs 的一种表现形式。除此之外，dfs 还有另一种表现形式，它使用的是局部变量，类似于记忆；而回溯使用的是全局变量。dfs 一般都是以递归形式呈现的。因为这样清楚。（dp 有时用递归也是因为如此。）除非内存不够，一般不会手动写栈。

作者：甘文迪许
链接：https://www.zhihu.com/question/266403334/answer/426371707
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

个人理解：
递归，dfs，回溯属于一类算法，都是通过递归来实现的；动态规划属于另外一类。
