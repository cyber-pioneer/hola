基本数据结构的构造，增，删，改，查

## 序列容器：

**std::vector**：动态数组，可以容纳任意数量的相同类型的元素，并提供快速的随机访问。
**std::deque**：双端队列，支持在序列的开头和结尾快速插入和删除元素。
**std::list**：双向链表，支持在任何位置快速插入和删除元素。
std::forward_list：单向链表，支持在序列的开头快速插入和删除元素。
**std::array**：固定大小的数组，提供了与C数组类似的接口，但更安全易用。
**std::string**：用于处理字符串的专用容器。

## 关联容器：

**std::set**：集合，包含唯一元素的容器，元素默认按升序排序。
**std::map**：关联数组，存储键值对（key-value pairs），其中键是唯一的，且默认按升序排序。
**std::unordered_map**：无序关联数组。

std::multiset：多重集合，允许元素重复。
std::multimap：多重关联数组，允许键重复。
std::unordered_set：无序集合，元素的插入顺序不保留，也不保证元素的排序。
std::unordered_multiset：无序多重集合。
std::unordered_multimap：无序多重关联数组。

## 容器适配器：
由于容器适配器没有提供直接的列表初始化构造函数，因此你不能像初始化底层容器那样直接使用列表初始化来初始化一个容器适配器。

```
std::stack<int> s {1, 2, 3, 4, 5}; // 错误！容器适配器不支持这样的列表初始化
```

**std::stack**：后进先出（LIFO）的容器适配器，底层通常使用std::deque或std::list实现。
**std::queue**：先进先出（FIFO）的容器适配器，底层通常使用std::deque或std::list实现。
std::priority_queue：具有优先级队列特性的容器适配器，元素的优先级由比较函数确定。

map & unordered_map效率
std::map

std::map是一个基于红黑树的关联容器，它总是按键的升序存储元素。
插入、删除和搜索操作在平均情况下的时间复杂度为O(log n)，其中n是容器中元素的数量。
由于它是基于树的，因此它保持了元素的排序顺序。
在迭代时，元素总是按照键的升序访问。
std::unordered_map

std::unordered_map是一个基于哈希表的关联容器，它存储的元素不是排序的。
在平均情况下，插入、删除和搜索操作的时间复杂度为O(1)，但在最坏情况下可能会退化到O(n)。然而，在实践中，哈希表通常提供了非常快的查找速度，尤其是在元素数量很大时。
unordered_map的性能对哈希函数的质量非常敏感。一个质量较差的哈希函数可能会导致哈希表出现性能问题。
在迭代时，元素的顺序是不确定的。
