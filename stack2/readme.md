## 容器（Containers）和容器适配器（Container Adapters）
标准模版库两种不同类型的组件，它们各自有特定的用途和设计目标。
以下是它们之间的主要区别：

**容器（Containers）**
定义：容器是标准模板库（STL）中用于存储和管理集合数据的类模板。它们提供了数据的存储、访问、修改和遍历等功能。

类型：C++标准库提供了多种类型的容器，包括序列容器（如std::vector, std::list, std::deque）和关联容器（如std::set, std::map, std::multiset, std::multimap）。

特性：容器直接管理其元素的存储和生命周期。它们通常具有动态大小，可以随着元素的添加或删除而增长或缩小。

性能：不同类型的容器在性能上有不同的特点。例如，std::vector在尾部插入和删除元素时效率很高，而std::list在任意位置插入和删除元素都较为高效。

**容器适配器（Container Adapters）**
定义：容器适配器是对已有容器的一种封装，提供了一种不同的接口或视图来访问和操作容器中的元素。它们不是独立的容器类型，而是基于现有容器实现的。

类型：C++标准库中的容器适配器包括std::stack, std::queue, 和std::priority_queue。这些适配器分别提供了堆栈、队列和优先队列的接口。

特性：容器适配器隐藏了底层容器的某些特性，只暴露出与特定数据结构（如堆栈或队列）相关的操作。这样可以使代码更加简洁、清晰，并降低出错的可能性。

性能：容器适配器的性能取决于其底层的容器实现。例如，如果使用std::deque作为std::queue的底层容器，那么队列操作的性能将受到std::deque性能特点的影响。

总结
容器是直接用于存储和管理数据的结构，具有动态大小和多种性能特点。

容器适配器则是基于现有容器实现的封装层，提供了特定数据结构的接口和视图，简化了某些类型数据的操作和管理。它们不直接管理数据存储，而是依赖于底层的容器来执行实际的数据操作。

## 容器适配器是否支持列表初始化，为什么？
C++容器适配器（如 std::stack、std::queue 和 std::priority_queue）本身不直接支持列表初始化（list initialization），因为容器适配器并不是独立的容器类型，而是对底层容器（如 std::deque、std::vector 等）的一种封装。列表初始化是一种直接通过花括号 {} 内提供初始元素列表来初始化对象的方式。

由于容器适配器没有提供直接的列表初始化构造函数，因此你不能像初始化底层容器那样直接使用列表初始化来初始化一个容器适配器。例如，以下代码是无效的：


std::stack<int> s {1, 2, 3, 4, 5}; // 错误！容器适配器不支持这样的列表初始化
然而，你可以通过先列表初始化一个底层容器，然后将其传递给容器适配器的构造函数来间接实现类似的效果。例如：


std::deque<int> d {1, 2, 3, 4, 5}; // 正确的列表初始化底层容器
std::stack<int> s(std::deque<int>(d)); // 使用初始化好的底层容器来构造容器适配器
或者更简洁地：


std::deque<int> d {1, 2, 3, 4, 5}; // 列表初始化底层容器
std::stack<int> s(d); // 直接使用底层容器来构造容器适配器
在这些例子中，我们首先使用列表初始化创建了一个 std::deque<int> 容器，并将其作为参数传递给 std::stack<int> 的构造函数。这样，我们就能够间接地利用列表初始化的优势来初始化容器适配器。

总的来说，虽然容器适配器本身不支持直接的列表初始化，但通过底层容器的列表初始化，我们仍然可以高效地初始化容器适配器。

### deque
stack和queue容器适配器默认是基于deque（双端队列）容器实现的。这意味着，当你创建一个stack或queue对象时，底层实际上使用了一个deque容器来存储元素。这种设计选择是因为deque容器在两端都能高效地进行元素的插入和删除操作，这使得它非常适合作为stack和queue的底层容器。
